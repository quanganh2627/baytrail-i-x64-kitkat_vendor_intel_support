#!/bin/bash
# build nand boot recovery image for android

TEMP=`getopt \
         -o c:r:k:o:p:t: \
         --long cmdline:,ramdisk:,kernel:,output:,product:,type: \
         -n '$0' \
         --  "$@"`

eval set -- "$TEMP"
while true ; do
    echo "+++++ case $1 +++++"
    case "$1" in
        --cmdline) CMDLINE="$2"; shift 2;;
        --ramdisk) INITRD=$2; shift 2;;
        --kernel) BZIMAGE=$2; shift 2;;
        --output) OUT=$2; shift 2;;
        --product) BOARD=$2; shift 2;;
        --type) TYPE=$2; shift 2;;
        --) shift ; break ;;
    esac
done

TARG=`dirname $OUT`
case "$TYPE" in
    mos) IMGNAME="boot";;
    recovery) IMGNAME="recovery";;
esac
if [ -z $IMGNAME ]; then
    echo "error: image type is not one of [mos|recovery]"
    exit 1
fi

UNSIGNED_OUT=${TARG}/${IMGNAME}.unsigned
CMDLINE_FILE=${TARG}/${IMGNAME}_cmdline
echo $CMDLINE > $CMDLINE_FILE
BOOTSTUB=vendor/intel/support/bootstub

if [[   "$BOARD" == "mfld_cdk" \
     || "$BOARD" == "mfld_pr1" \
     || "$BOARD" == "mfld_pr2" \
     || "$BOARD" == "mfld_gi" \
     || "$BOARD" == "mfld_dv10" \
     || "$BOARD" == "ctp_pr0" \
     || "$BOARD" == "ctp_pr1" \
   ]]; then
            SILICON=1;
    else
            SILICON=0;
    fi

if [ ! -e "${BZIMAGE}" ]; then
    echo "error: bzImage file ${BZIMAGE} does not exist"
    exit 1
fi

if [ ! -e "${INITRD}" ]; then
    echo "error: ramdisk.img file ${INTRD} does not exist"
    exit 1
fi

if [ ! -e "${CMDLINE_FILE}" ]; then
    echo "error: cmdline file ${CMDLINE} does not exist"
    exit 1
fi

if [ ! -e ${BOOTSTUB} ]; then
    echo "error: bootstub file ${BOOTSTUB} does not exist"
    exit 1
fi

if [ -e "${OUT}" ]; then
    echo "${OUT} exists, remove the old one"
    rm -f ${OUT}
fi

echo "Creating image \`${OUT}'for FSTK stitching..."

rm -f ${UNSIGNED_OUT}
./vendor/intel/support/stitch.sh ${CMDLINE_FILE} ${BOOTSTUB} ${BZIMAGE} ${INITRD} 0 ${SILICON} ${UNSIGNED_OUT}

if [ "0" -ne "$?" ]; then
    echo "error running stitch.sh for generating ${UNSIGNED_OUT}"
    exit 1
fi
TOP=`pwd`
# stitch binary
readlink -e device/intel/PRIVATE/xfstk-stitcher
if [ $? -eq 0 ]; then
    # use new xfstk-stitcher tool
    if [ $TYPE == "mos" ]; then
        # generate the MAIN OS version of this image
        ./device/intel/PRIVATE/xfstk-stitcher/gen-os.sh --input ${TOP}/${UNSIGNED_OUT} --output ${TOP}/${OUT} --xml MOS.XML
    else
        # generate the POS OTA version of this image
        ./device/intel/PRIVATE/xfstk-stitcher/gen-os.sh --input ${TOP}/${UNSIGNED_OUT} --output ${TOP}/${OUT} --xml POSOTA.XML
        # generate the POS version of this image
        ./device/intel/PRIVATE/xfstk-stitcher/gen-os.sh --input ${TOP}/${UNSIGNED_OUT} --output ${TOP}/${OUT}.POS.bin --xml POS.XML
    fi
else
    # use legacy lfstk
    if [ $TYPE == "mos" ]; then
        # generate the MAIN OS version of this image
        ./device/intel/PRIVATE/lfstk/gen-os.sh ${TOP}/${UNSIGNED_OUT} ${TOP}/${OUT} PAYLOADOS.XML
    else
        # generate the POS OTA version of this image
        ./device/intel/PRIVATE/lfstk/gen-os.sh ${TOP}/${UNSIGNED_OUT} ${TOP}/${OUT} POSOTA.XML
        # generate the POS version of this image
        ./device/intel/PRIVATE/lfstk/gen-os.sh ${TOP}/${UNSIGNED_OUT} ${TOP}/${OUT}.POS.bin POS.XML
    fi
fi

# clean up
cd  $TOP
echo "Done."
